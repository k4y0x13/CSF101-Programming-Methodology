# Practical 12: Object Oriented Programming Principles

## Objective
In this lab, you will implement Encapsulation, Basic Inheritance, Abstraction, Polymorphism in exercises. This exercise will help you understand the concepts.

**Submission Date:** 

## Prerequisites
- Basic knowledge of Python syntax
- Understanding of lists and functions in Python
- Familiarity with time complexity concepts (optional, but helpful)

## Lab Steps

### Step 1: Encapsulation with Public, Protected, Private Variables
This public variable is accessible outside of the object
```python
class MyClass:
    def __init__(self, name):
        self.name = name  # Public variable
obj = MyClass("John")
print(obj.name)
```
This private variable access throws error
```python
class MyClass:
    def __private_method(self):
        print("This is a private method")
obj = MyClass()
obj.__private_method()
```
Trying to access the private variable outside the class with obj.__salary raises AttributeError

Expecting Output: Salary: 50000
```python
class MyClass:
    def __init__(self, name, age, salary):
        self.__salary = salary  # Private variable
    def display_salary(self):
        print(f"Salary: {self.__salary}")  # Accessible within the class
obj = MyClass("John", 30, 50000)
obj.display_salary()  
print(obj.__salary)
```

### Step 2: Encapsulation with Instance Methods, Class Method versus Static Method
This calculator class has two methods: add as a class method and multiply as a static method. We accessed these methods using the class name Calculator without creating an object of the class. 

We used the @classmethod and @staticmethod decorators to define these methods.
In contrast, **normal instance methods** have no decorators.

```python
class Calculator:
    @classmethod
    def add(cls, num1, num2):
        return num1 + num2
    
    @staticmethod
    def multiply(num1, num2):
        return num1 * num2

print(Calculator.add(2,3))
print(Calculator.multiply(2,3))
```

### Step 3: Basic Inheritance
Employee is subclass of Person. super() function is used to call the parent class’s methods, and leverage the functionality of the parent class.

```python
# Parent Class: Person
class Person:
    def __init__(self, name, idnumber):
        self.name = name
        self.idnumber = idnumber

    def display(self):
        print(self.name)
        print(self.idnumber)

# Child Class: Employee
class Employee(Person):
    def __init__(self, name, idnumber, salary, post):
        super().__init__(name, idnumber)  
	# Using super() to call Person's __init__()
        self.salary = salary
        self.post = post

employee1 = Employee("Sonam", 22404, 60000, "student")
employee1.display()
```
### Step 4: Data Abstraction
- Create abstract base class Car
- Import required modules
- Create child class Hatchback

```python
from abc import ABC, abstractmethod
class Car(ABC):
    def __init__(self, brand, model, year):
        self.brand = brand
        self.model = model
        self.year = year

    # Create abstract method      
    @abstractmethod
    def printDetails(self):
        pass
    # Create concrete method
    def accelerate(self):
        print("Speed up ...")  

class Hatchback(Car):
    def printDetails(self):
        print("Brand:", self.brand)
        print("Model:", self.model)
        print("Year:", self.year)
  
    def sunroof(self):
        print("Not having this feature")

car1 = Car(”Toyota”, “Prius”, “2004”)
hatch1 = Hatchback(”Toyota”, “Prius”, “2004”)
```

### Step 5: Class Polymorphism
Runtime polymorphism is achieved through method overriding. The study() method exhibits polymorphic behavior based on the object calling it.
```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def study(self):
        print(self.name, " is studying Python.")

class HighSchoolStudent(Student):
    def __init__(self, name, age, grade):
        super().__init__(name, age)
        self.grade = grade
    
    def study(self):
        print(self.name, " is studying Mathematics.")

Karma = Student("Karma", 25)
Karma.study()

Sonam = HighSchoolStudent("Sonam Lhamo", 20, 12)
Sonam.study()
```

### Step 6: Function Polymorphism
Methods can be written to have different behaviour depending of type of inputs received  There are some functions in Python which are compatible to run with multiple data types. One such function is the len() function. It can run with many data types in Python. Let's look at some example use cases of the function

```python
# Length of String
print(len("Programiz"))
# Length of List
print(len(["Python", "Java", "C"]))
# Length of Dictionary
print(len({"Name": "John", "Address": "Nepal"}))
```

### Step 7: Operator Polymorphism
This is the ability to use common operations in different forms for different data inputs. Operator Overloading means giving extended meaning beyond their predefined operational meaning. 
``` python
class complex:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    
    # adding two objects
    def __add__(self, other):
        return self.a + other.a, self.b + other.b

Ob1 = complex(1, 2)
Ob2 = complex(2, 3)
Ob3 = Ob1 + Ob2
print(type(Ob3), Ob3)
```

### Step 8:  Run through OOP unit Worksheet 2
Run through OOP unit Worksheet 2 on Online Banking Application

[Worksheet1](../OOP/Worksheet1.html)

## Exercises for Students

1. Implement various different variables, methods and classes based on principles of Encapsulation, Basic Inheritance, Abstraction, Polymorphism.

## Conclusion

In this lab, you've implemented and tested further concepts on OOP.

Key takeaways:
- 

