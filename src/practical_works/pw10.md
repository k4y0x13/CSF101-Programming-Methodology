# Practical 8: Algorithms Backtracking and Recursions Exercises

## Objective
In this lab, you will implement backtracking and recursion exercises. This exercise will help you understand the mechanics of these algorithms and compare their performance.

**Submission Date:** November 4st

## Prerequisites
- Basic knowledge of Python syntax
- Understanding of lists and functions in Python
- Familiarity with time complexity concepts (optional, but helpful)

## Part 1: Factorial
Let's create a recursive function to generate factorial solution:

```python
def factorial(n):
    if n == 1:
        return 1
    else:
        return (n * factorial(n-1))

# Test the function
n=3
print("The factorial of", num, "is", factorial(num))
```

## Part 2: Fibonacci Generator
### Step 1: Implement a Recursive Fibonacci Generator
Let's create a recursive function to generate Fibonacci numbers:

```python
def fibonacci_recursive(n):
    if n <= 1:
        return n
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

# Test the function
for i in range(10):
    print(f"F({i}) = {fibonacci_recursive(i)}")
```

### Step 2: Implement an Iterative Fibonacci Generator

Now, let's create an iterative function to generate Fibonacci numbers:

```python
def fibonacci_iterative(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

# Test the function
for i in range(10):
    print(f"F({i}) = {fibonacci_iterative(i)}")
```

### Step 3: Compare Performance

Let's create a function to measure the execution time of both approaches:

```python
import time

def measure_time(func, n):
    start = time.time()
    result = func(n)
    end = time.time()
    return result, end - start

# Test both functions and compare their execution times
n = 30
recursive_result, recursive_time = measure_time(fibonacci_recursive, n)
iterative_result, iterative_time = measure_time(fibonacci_iterative, n)

print(f"Recursive: F({n}) = {recursive_result}, Time: {recursive_time:.6f} seconds")
print(f"Iterative: F({n}) = {iterative_result}, Time: {iterative_time:.6f} seconds")
```

### Step 4: Implement a Generator Function for Fibonacci Sequence

Now, let's create a generator function that yields Fibonacci numbers:

```python
def fibonacci_generator(limit):
    a, b = 0, 1
    count = 0
    while count < limit:
        yield a
        a, b = b, a + b
        count += 1

# Test the generator
for i, fib in enumerate(fibonacci_generator(10)):
    print(f"F({i}) = {fib}")
```

### Step 5: Implement Memoization for Recursive Fibonacci

To improve the performance of the recursive approach, let's implement memoization:

```python
def fibonacci_memoized(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci_memoized(n-1, memo) + fibonacci_memoized(n-2, memo)
    return memo[n]

# Test the memoized function
for i in range(10):
    print(f"F({i}) = {fibonacci_memoized(i)}")

# Compare performance with the original recursive function
n = 30
memoized_result, memoized_time = measure_time(fibonacci_memoized, n)
print(f"Memoized: F({n}) = {memoized_result}, Time: {memoized_time:.6f} seconds")
```

## Part 3 Problem: Climbing Stairs

### 1. Problem Statement

You are climbing a staircase. It takes `n` steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Example 1:**
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

**Example 2:**
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step

**Constraints:**
- 1 <= n <= 45

### 2. Conceptual Understanding

This problem is about finding the number of different combinations to reach a goal (the top of the stairs) given a set of fixed moves (1 or 2 steps at a time).

Think of it like this: You're standing at the bottom of a staircase, and for each step, you have two choices: take 1 step or take 2 steps. We need to count all the possible sequences of these choices that lead to the top.

This problem introduces the concept of dynamic programming, where we build the solution to a larger problem from solutions to smaller subproblems.

We'll use the Dynamic Programming approach:

1. Create an array `dp` where `dp[i]` represents the number of ways to climb to the i-th step.
2. Initialize the base cases: `dp[1] = 1` (one way to climb 1 step) and `dp[2] = 2` (two ways to climb 2 steps).
3. For steps 3 to n, the number of ways to reach step i is the sum of ways to reach the previous step (and then take 1 step) and the ways to reach two steps back (and then take 2 steps).
   So, `dp[i] = dp[i-1] + dp[i-2]`
4. Return `dp[n]` as the final answer.

This approach is optimal because it solves each subproblem only once and uses the results to build up to the final solution.

### 3. Python Implementation

```python
def climbStairs(n):
    if n <= 2:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

- We use a list `dp` to store the number of ways for each step.
- We initialize the base cases for 1 and 2 steps.
- We then iterate from 3 to n, filling in the `dp` array.
- The final answer is in `dp[n]`.

## Part 4: Tower of Hanoi

### 1. Problem Statement

The Tower of Hanoi is a classic problem in computer science and mathematics. The problem setup is as follows:

- There are three rods and a number of disks of different sizes which can slide onto any rod.
- The puzzle starts with the disks neatly stacked in ascending order of size on one rod, the smallest disk at the top.
- The objective of the puzzle is to move the entire stack to another rod, obeying the following rules:
  1. Only one disk can be moved at a time.
  2. Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty rod.
  3. No larger disk may be placed on top of a smaller disk.

Your task is to write a function that prints out the series of moves required to solve the Tower of Hanoi puzzle for n disks.

**Example:**
Input: n = 3 (number of disks)
Output: 
```
Move disk 1 from rod A to rod C
Move disk 2 from rod A to rod B
Move disk 1 from rod C to rod B
Move disk 3 from rod A to rod C
Move disk 1 from rod B to rod A
Move disk 2 from rod B to rod C
Move disk 1 from rod A to rod C
```

### 2. Conceptual Understanding

The Tower of Hanoi problem is an excellent example of a problem that can be solved using recursion. The key insight is that to move n disks:

1. Move n-1 disks from the source to the auxiliary rod.
2. Move the largest disk from the source to the destination rod.
3. Move the n-1 disks from the auxiliary rod to the destination rod.

This process is recursive because moving n-1 disks involves the same process with a smaller number of disks.

Think of it like unpacking nested boxes. You need to unpack the smaller boxes (move smaller disks) before you can move the largest box (disk).

The recursive solution follows these steps:

1. Base case: If there's only one disk, move it directly from the source to the destination.
2. Recursive case:
   a. Move n-1 disks from source to auxiliary rod.
   b. Move the nth disk from source to destination.
   c. Move n-1 disks from auxiliary to destination.

This approach elegantly solves the problem by breaking it down into smaller, manageable subproblems.

### 5. Python Implementation

```python
def tower_of_hanoi(n, source, destination, auxiliary):
    if n == 1:
        print(f"Move disk 1 from rod {source} to rod {destination}")
        return
    tower_of_hanoi(n-1, source, auxiliary, destination)
    print(f"Move disk {n} from rod {source} to rod {destination}")
    tower_of_hanoi(n-1, auxiliary, destination, source)

# Example usage
n = 3
tower_of_hanoi(n, 'A', 'C', 'B')
```

## Part 5: Combination Sum


## Part 6: Word Search


## Part 7: Permutations


- The function takes four parameters: the number of disks `n`, and the names of the source, destination, and auxiliary rods.
- The base case (n == 1) simply moves the disk and returns.
- For n > 1, we recursively move n-1 disks, then move the nth disk, then recursively move the n-1 disks again.

## Further Exercises for Students

1. Modify the iterative function to return a list of Fibonacci numbers up to n, instead of just the nth number.
2. Implement a function that finds the index of the first Fibonacci number that exceeds a given value.
3. Create a function that determines if a given number is a Fibonacci number.
4. Implement a function that calculates the ratio between consecutive Fibonacci numbers and observe how it approaches the golden ratio.

## Discussion Questions

1. What are the advantages and disadvantages of the recursive approach compared to the iterative approach?
2. How does memoization improve the performance of the recursive function? Are there any drawbacks?
3. In what scenarios might you prefer to use a generator function over other implementations?
4. How does the space complexity differ between these implementations?

## Conclusion

In this lab, you've implemented multiple approaches to generate Fibonacci sequences in Python. You've explored recursive, iterative, and generator-based solutions, as well as an optimization technique (memoization). By comparing these approaches, you can gain insights into algorithm design, performance optimization, and the trade-offs between different implementation strategies.

Key takeaways:
- 

